# SPDX-FileCopyrightText: Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
from collections.abc import AsyncGenerator

from pydantic import Field

from nat.builder.builder import Builder
from nat.builder.framework_enum import LLMFrameworkEnum
from nat.builder.function_info import FunctionInfo
from nat.cli.register_workflow import register_function
from nat.data_models.component_ref import LLMRef
from nat.data_models.function import FunctionBaseConfig

logger = logging.getLogger(__name__)


class AutoGenFunctionConfig(FunctionBaseConfig, name="autogen_team"):
    """Configuration for AutoGen Agent workflow."""

    llm_name: LLMRef = Field(description="The LLM model to use with AutoGen agents.")
    tool_names: list[str] = Field(default_factory=list, description="List of tool names to be used by the agents.")
    mcp_server_url: str = Field(
        default="http://0.0.0.0:9901/mcp",
        description="URL for the MCP time server.",
    )
    query_processing_agent_name: str = Field(description="Name of the query processing agent")
    query_processing_agent_instructions: str = Field(description="Instructions for the query processing agent")
    final_response_agent_name: str = Field(description="Name of the final response agent")
    final_response_agent_instructions: str = Field(description="Instructions for the final response agent")


@register_function(config_type=AutoGenFunctionConfig, framework_wrappers=[LLMFrameworkEnum.AUTOGEN])
async def autogen_team(config: AutoGenFunctionConfig, builder: Builder) -> AsyncGenerator[FunctionInfo, None]:
    """
    AutoGen multi-agent workflow that demonstrates collaborative agents in a team.
    The agents communicate through AutoGen's conversation system to produce output.

    Args:
        config (AutoGenFunctionConfig): Configuration for the workflow.
        builder (Builder): The NAT workflow builder to access registered components.

    Yields:
        AsyncGenerator[FunctionInfo, None]: Yields a FunctionInfo object encapsulating the workflow.
    """

    from autogen_agentchat.agents import AssistantAgent
    from autogen_agentchat.conditions import TextMentionTermination
    from autogen_agentchat.teams import RoundRobinGroupChat
    from autogen_ext.tools.mcp import StreamableHttpMcpToolAdapter
    from autogen_ext.tools.mcp import StreamableHttpServerParams

    try:
        llm_client = await builder.get_llm(config.llm_name, wrapper_type=LLMFrameworkEnum.AUTOGEN)
        tools = await builder.get_tools(config.tool_names, wrapper_type=LLMFrameworkEnum.AUTOGEN)

        time_server_params = StreamableHttpServerParams(
            url=config.mcp_server_url,
            headers={"Content-Type": "application/json"},
            timeout=30,
        )
        adapter = await StreamableHttpMcpToolAdapter.from_server_params(time_server_params, "current_datetime")
        tools.append(adapter)

        query_processing_agent = AssistantAgent(name=config.query_processing_agent_name,
                                                model_client=llm_client,
                                                tools=tools,
                                                system_message=config.query_processing_agent_instructions)
        final_response_agent = AssistantAgent(name=config.final_response_agent_name,
                                              model_client=llm_client,
                                              system_message=config.final_response_agent_instructions)

        team = RoundRobinGroupChat(participants=[query_processing_agent, final_response_agent],
                                   termination_condition=TextMentionTermination("APPROVE"))

        async def _autogen_team_workflow(user_input: str) -> str:
            """Execute the workflow with the given input.

            Args:
                user_input (str): User's query

            Returns:
                str: The final response generated by the team.
            """
            try:
                result = await team.run(task=user_input)

                if hasattr(result, 'messages') and result.messages:
                    return result.messages[-1].content
                else:
                    return "The workflow finished but no output was generated."

            except Exception as e:
                logger.exception("Error in AutoGen workflow")
                return f"Error occurred during AutoGen workflow: {e!s}"

        # Yield the function info
        yield FunctionInfo.create(single_fn=_autogen_team_workflow)

    except GeneratorExit:
        logger.info("AutoGen workflow exited early")
    except Exception as _e:
        logger.exception("Failed to initialize AutoGen workflow")
        raise
    finally:
        logger.debug("AutoGen workflow cleanup completed")
